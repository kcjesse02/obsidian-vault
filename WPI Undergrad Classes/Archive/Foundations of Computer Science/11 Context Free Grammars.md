A Context-Free Grammar is a 4-tuple(V, $\Sigma$, R, S)

V - finite set of variables
$\Sigma$ - finite set of Terminal Symbols
R - FInite set of rules
S - Start Variable

**Context-free**: terminals must only transform variables, must not transform anything with the variable (see Q1)

Called context free because the information is all in the variables, no information about previous substitutions

A string is part of a context-free grammar if it can be generated with a finite number of steps with the grammar

*Language*
set of words that belong to $\Sigma^*$
Context-free language if can be generated with context-free grammar


## Some Questions and Examples

**Q1: Prove that any finite language is context-free**
- 1 Start Variable
- Substitution: n substitutions for each string in the language
- Number of rules will be finite as long as the language is finite

not all languages are context free:

$C_1:$ B -> 0B1 | $\epsilon$
	B1 -> 1B
	0B -> 0B

not context free
depends on something to the right of the variable(B1) and something to the left of the variable(0B)

$C_2:$ S -> 0S | S1
	R -> RR

This is valid!
Recognizes and empty language

#### Q2: Are all regular languages context free?
*Idea:* no, I don't think so. Some rely on counting!
	ex: all binary strings with a length of a multiple of 3
- there are infinite languages that are regular

**Any regular language is also context free**
- a states can be modeled with variables
- transitions modeled as changed to variables
- accept states modeled as $\epsilon$ moves
![[Screenshot 2023-09-19 at 12.01.02 PM.png|500]]
you can convert an Automaton into CFG

![[Screenshot 2023-09-19 at 12.04.16 PM.png]]
![[Screenshot 2023-09-19 at 12.06.59 PM.png]]

### Proof Example
1. 
L={$a^{n}b^{n}|n\geq1$}
G: S-> aSb | ab
1. Language can be generated by language
	![[Screenshot 2023-09-18 at 12.59.25 PM.png]]
2. Grammar only generates thing contained in the language
![[Screenshot 2023-09-18 at 12.59.50 PM.png]]	



Palindrome Language
$L=\{w=w^R\}$

S -> 0S0 | 1S1 | 1 | 0 $\epsilon$

## Closure Properties
#### Closure under union
you can just or the path to the other language
- we assume the languages are disjoint
![[Screenshot 2023-09-19 at 12.15.49 PM.png]]

## Parse Trees
- tool for understanding what a CFG does
![[Screenshot 2023-09-19 at 12.22.59 PM.png|500]]![[Screenshot 2023-09-19 at 12.25.00 PM.png|500]]

### Ambiguity
![[Screenshot 2023-09-19 at 12.30.08 PM.png]]
- its not clear how to evaluate this expression
- multiple parse tress
![[Screenshot 2023-09-19 at 12.31.03 PM.png]]

Leftmost Derivation: evaluate the thing to the left first
- like how we read english
- direction is not a constant in human language though